<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Data Frog</title>
    <link rel="stylesheet" href="../../style.css" />
</head>
<body>
    <h1>NumPy for Basics (part one)</h1>
    <main>
        <p><a href="/index.html">Go home</a></p>
<p><a href="https://numpy.org/doc/stable/user/basics.html">NumPy Article for beginners</a></p>
<h2>Basics of NumPy</h2>
<h3>Array Creation</h3>
<ol>
<li>Conversion from other Python structures</li>
<li>The built in NumPy array creation functions</li>
<li>By replicating, joining or mutating existing arrays</li>
<li>Reading arrays from disk, either standard or custom formats</li>
<li>From raw bytes thru the use of strings or buffers</li>
<li>Special library functions, like random</li>
</ol>
<h4>Making Arrays from Python sequences</h4>
<p>The NumPy arrays can be made from lists and tuples. Lists are as [...] and tuples (...).</p>
<ul>
<li>a list will make a 1D array</li>
<li>a list of list will create a 2D array</li>
<li>any further nested will create higher dimension arrays. The array objects dimension is represented by the concept of ndarray in NumPy.</li>
</ul>
<p>When using a <code>numpy.array</code> to make an array it's important to be careful of the dtype or the data type of the array. It's important to not have an overflow. For example, and 8-bit signed integer represents a number from -128 to 127. So if you tried to assign a number like 128 or 129 to a dtype=np.int8.</p>
<p>When performing operations with two arrays with the same type (dtype) of uint32, for example, the resulting array is hte same type.</p>
<p>When performing operations that different dtypes, NumPy will assign a new type that satisfies all the array elements involved in the computation. For example, uint32 and int32 can be both represented by int64.</p>
<p>The default behavior is to create arrays as either 32 or 64 bit signed integers depending on the platform. Or even a double precision floating point number like int32/int64. If you want a specific type otherwise you need to specify the type.</p>
<h4>Built in NumPy array creation functions</h4>
<p>There are over 40 built-in functions for creating arrays. There are 3 broad categories of array creator functions.</p>
<ol>
<li>1D arrays</li>
<li>2D arrays</li>
<li>ndarrays (more than two dimensions)</li>
</ol>
<h5>1D Arrays</h5>
<p>For 1D or 1 dimension arrays there's <code>numpy.linspace</code> and <code>numpy.arange</code>. Generally there needs to be at least two inputs start and stop.</p>
<p>The <code>numpy.arange</code> creates arrays with regular incrementing values. Best use in <code>numpy.arange</code> is to use a start, end, and step. And if you want to use a non-integer incrementor / step you want to use a <code>dtype</code> of float.</p>
<h5>2D Arrays</h5>
<p>The 2D array creation functions are <code>numpy.eye</code>, <code>numpy.diag</code>, and <code>numpy.vander</code>.</p>
<p>And example of using the <code>numpy.eye</code> creation process is <code>np.eye(n, m)</code>. The elements are where <code>i=j</code> (that is the row index and column index being equal) and are 1. The rest are equal to 0.</p>
<p>For example:</p>
<p><code>np.eye(3) array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]) np.eye(3, 5) array([[1., 0., 0., 0., 0.], [0., 1., 0., 0., 0.], [0., 0., 1., 0., 0.]])</code></p>
<p>The <code>numpy.diag</code> can be defined as a 2D array with the given values along the diagonal. Or if given a 2D array returns a 1D array that is only the diagonal elements.</p>
<p>These two functions can be helpful for doing linear algebra.</p>
<p><code>np.diag([1, 2, 3]) array([[1, 0, 0], [0, 2, 0], [0, 0, 3]]) np.diag([1, 2, 3], 1) array([[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3], [0, 0, 0, 0]]) a = np.array([[1, 2], [3, 4]]) np.diag(a) array([1, 4])</code></p>
<p>The <code>vander(x, n)</code> defines a Vendermonde matrix as a 2D NumPy array.</p>
<p>Each column of the Vandemonde matrix is a decreasing power of the input. That is the 1D array (the list or tuple) that was passed in to make the matrix.</p>
<p>The <code>x</code> being where the highest polynomial order as is <code>n-1</code>. This array creation routine is useful in generating linear least square models.</p>
<p><code>np.vander(np.linspace(0, 2, 5), 2) array([[0. , 1. ], [0.5, 1. ], [1. , 1. ], [1.5, 1. ], [2. , 1. ]]) np.vander([1, 2, 3, 4], 2) array([[1, 1], [2, 1], [3, 1], [4, 1]]) np.vander((1, 2, 3, 4), 4) array([[ 1,  1,  1,  1], [ 8,  4,  2,  1], [27,  9,  3,  1], [64, 16,  4,  1]])</code></p>
<h4>general ndarray creation function</h4>
<p>(to be continued)</p>

    </main>
    <footer>
        <div>
            <div>Sponsored by Frog Protection Services</div>
            <div>Do you have Frog Protection?</div>
        </div>
        <div>a <code class="logo">hello world</code> production</div>
    </footer>
</body>
</html>