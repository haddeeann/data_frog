<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Data Frog</title>
    <link rel="stylesheet" href="../../style.css" />
</head>
<body>
    <h1>Subclassing</h1>
    <main>
        <p><a href="/index.html">Go home</a></p>
<p><a href="https://numpy.org/doc/stable/user/basics.subclassing.html">Custom Array Containers</a></p>
<h2>Subclassing ndarray</h2>
<p>Subclassing can be done in three basic ways:</p>
<ol>
<li>Explicit constructor call, <code>MySubClass(params)</code>. This is the usual route to Python instance creation.</li>
<li>View casting, casting an existing ndarray as a given subclass</li>
<li>New from template, creating a new instance from a template instance. Examples include returning slices from a subclassed array, creating return types from ufuncs, and copying arrays.</li>
</ol>
<p>The last two are characteristics of <code>ndarrays</code>. In order to support things like array slicing. The complications of subclassing the <code>ndarray</code> are due to the mechanisms NumPy has to support these latter two routes of an instance creation.</p>
<h2>When to use subclassing</h2>
<p>Besides the additional complexities of subclassing a NumPy array, subclasses can run into unexpected behavior because of some functions may convert to the subclass to a baseclass and &quot;forget&quot; any additional information associated with the subclass.</p>
<p>This can result in surprising behavior if you use NumPy methods or functions you have not explicitly tested.</p>
<p>On the other hand, compared to other interoperability approaches, subclassing can be a useful because many things will just 'work'.</p>
<p>This means that subclassing can be a convenient approach.</p>
<p>NumPy now provides additional interoperability protocols described in &quot;Interoperability with NumPy&quot;.</p>
<p>For many use cases these interoperability protocols may now be a better fit or supplement the use of subclassing.</p>
<p>Subclassing can be a good fit if:</p>
<ul>
<li>you aren't worried about maintainability or users other than yourself.</li>
<li>you don't think it's problematic if the subclass information is ignored or lost silently.</li>
</ul>
<h2>View Casting</h2>
<p>View casting is the stand ndarray mechanism by which you take an ndarray of any subclass and return a view of the array as another (specified) subclass.</p>
<p>A new instance of an ndarray subclass can also come about by a very similar mechanism to View Casting, when NumPy finds it needs to create a new instance from a template instance. The most obvious place this has to happen is when you are taking slices of subclassed arrays.</p>
<p>The slice is a view onto the original c_arr data. So when we take a view from the ndarray we return a new ndarray of the same class. One that points to the data in the original.</p>
<p>There are other points in the use of ndarrays where we need such views, such as copying arrays, creating ufunc output arrays and reducing methods.</p>
<h2>The Role of <strong>array_finalize</strong></h2>
<p>The <strong>array_finalize</strong> is the mechanism that NumPy provides to allow subclasses to handle the various ways that the new instances get created.</p>
<p>So by defining a specific <strong>array_wrap</strong> method for our subclass, we can tweak the output from unfuncs. The <strong>array_wrap</strong> method requires self, then an argument which is the result of the ufunc and an optional parameter context.</p>
<p>The default implementation does nothing but pass through the array.</p>

    </main>
    <footer>
        <div>
            <div>Sponsored by Frog Protection Services</div>
            <div>Do you have Frog Protection?</div>
        </div>
        <div>a <code class="logo">hello world</code> production</div>
    </footer>
</body>
</html>