<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Data Frog</title>
    <link rel="stylesheet" href="/static/style.css" />
</head>
<body>
    <header>
        <div class="logo">
            <img src="/static/frog_logo.webp" alt="Frog Protection">
        </div>
        <div class="logo-text-small">
            <div>Data Science Personal Journey</div>
        </div>
    </header>
    <main>
        <h1>Subclassing</h1>
<p><a href="/index.html">Go home</a></p>
<p><a href="https://numpy.org/doc/stable/user/basics.subclassing.html">Custom Array Containers</a></p>
<h2>Subclassing ndarray</h2>
<p>Subclassing can be done in three basic ways:</p>
<ol>
<li>Explicit constructor call, <code>MySubClass(params)</code>. This is the usual route to Python instance creation.</li>
<li>View casting, casting an existing <code>ndarray</code> as a given subclass</li>
<li>New from template, creating a new instance from a template instance. Examples include returning slices from a subclassed array, creating return types from <code>ufuncs</code>, and copying arrays.</li>
</ol>
<p>The last two are characteristics of <code>ndarrays</code>. In order to support things like array slicing. The complications of subclassing the <code>ndarray</code> are due to the mechanisms NumPy has to support these latter two routes of an instance creation.</p>
<h2>When to use subclassing</h2>
<p>Besides the additional complexities of subclassing a NumPy array, subclasses can run into unexpected behavior because of some functions may convert to the subclass to a baseclass and &quot;forget&quot; any additional information associated with the subclass.</p>
<p>This can result in surprising behavior if you use NumPy methods or functions you have not explicitly tested.</p>
<p>On the other hand, compared to other interoperability approaches, subclassing can be a useful because many things will just
&quot;work&quot;.</p>
<p>This means that subclassing can be a convenient approach.</p>
<p>NumPy now provides additional interoperability protocols described in &quot;Interoperability with NumPy&quot;.</p>
<p>For many use cases these interoperability protocols may now be a better fit or supplement the use of subclassing.</p>
<p>Subclassing can be a good fit if:</p>
<ul>
<li>you aren't worried about maintainability or users other than yourself.</li>
<li>you don't think it's problematic if the subclass information is ignored or lost silently.</li>
</ul>
<p>Note that subclass authors may wish to study Interoperability with NumPy to support more complex use-cases or work around the surprising behavior.</p>
<p>Astropy's Quantity is an example which uses a dual approach of both subclassing and interoperability protocols.</p>
<h2>View Casting</h2>
<p>View casting is the standard <code>ndarray</code> mechanism by which you take an <code>ndarray</code> of any subclass, and return a view of the array as another (specified) subclass.</p>
<p>A new instance of an <code>ndarray</code> subclass can also come about by a very similar mechanism to <code>View Casting</code>. When NumPy finds it needs to create a new instance from a template instance. The most obvious place this has to happen is when you are taking slices of subclassed arrays.</p>
<p>The slice is a view onto the original <code>c_arr</code> data. So, when we take a view from the <code>ndarray</code>, we return a new <code>ndarray</code> of the same class. One that points to the data in the original.</p>
<p>There are other points in the use of <code>ndarrays</code> where we need such views, such as copying arrays (<code>c_arr.copy()</code>), creating <code>ufunc</code> output arrays and reducing methods (like <code>c_arr.mean()</code>).</p>
<h2>The Role of <strong>array_finalize</strong></h2>
<p>The <strong>array_finalize</strong> is the mechanism that NumPy provides to allow subclasses to handle the various ways that the new instances get created.</p>
<p>So by defining a specific <strong>array_wrap</strong> method for our subclass, we can tweak the output from <code>unfuncs</code>. The <strong>array_wrap</strong> method requires self, then an argument which is the result of the <code>ufunc</code> and an optional parameter context.</p>
<p>The default implementation does nothing but pass through the array.</p>

    </main>
    <footer>
        <div>
            <div>Sponsored by Frog Protection Services</div>
            <div>Do you have Frog Protection?</div>
        </div>
        <div>a <code class="logo">hello world</code> production</div>
    </footer>
</body>
</html>