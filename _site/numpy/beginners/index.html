<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Data Frog</title>
    <link rel="stylesheet" href="../../style.css" />
</head>
<body>
    <h1>NumPy for Beginners</h1>
    <main>
        <p><a href="/index.html">Go home</a></p>
<p><a href="https://numpy.org/doc/stable/user/absolute_beginners.html">NumPy Article for beginners</a></p>
<p>NumPy stands for Numerical Python. It's used in a lot of science and engineering.</p>
<p>NumPy is the universal standard for working with numerical data in Python. It's used in many other libraries and Python packages.</p>
<h3>NumPy and Arrays</h3>
<p>The main way of manipulating data in NumPy is through various kinds of arrays. There are multidimensional arrays, matrix data structures, and ndarray. Ndarray is a homogeneous n-dimensional array object.</p>
<p>One of the differences between a Python list and NumPy array is that a NumPy array contains all the same data. NumPy arrays are also more memory efficient and allow the data types to be specified.</p>
<p>The array in NumPy is the central data type used. The array contains meta information about the array. It's a grid of values and has info about the raw data, how to locate the element, and how to interpret an element.</p>
<p>This grid of info that is called an array can be indexed in different ways. The one dimensional array can be indexed, sliced, and iterated over like other Python enumerable sequences.</p>
<p>Multidimensional arrays can have more than one index per axis and those indices are given in a tuple.</p>
<p>A NumPy array can be made from a Python list. To make a Python list into a two or higher dimensional data then use a nested list.</p>
<p><code>a = np.array([1, 2, 3, 4, 5])</code></p>
<p>To access the data in an NumPy array you can do it like a Python list:</p>
<p><code>num_value = a[2]</code></p>
<p>The type of data is referred to as the dtype.</p>
<h3>The ndarray</h3>
<p>A ndarray is shorthand for &quot;N-dimensional array&quot;. You can have more than one dimension in the array. Which is difficult to imagine as a new person.</p>
<p>To think about the differences between one and two-dimensional arrays consider the difference between a flat piece of paper with a grid drawn on it to a cube.</p>
<p>A vector is an array with a single dimension, a matrix has two dimensions. And for three dimensions or more it's commonly called a tensor.</p>
<p>A NumPy ndarray class can represent matrices and vectors.</p>
<h3>Array Attributes</h3>
<p>The attributes of an array describe the aspects of the array. In NumPy the dimensions are called axes.</p>
<p>The array itself is usually fixed sized, has to have the same type of data and size of data. The shape of the array itself determines the number of dimensions. The shape of the array is a tuple.</p>
<p>For example, an array with two axes. With the first axes having a length of two and the second has a length of three.</p>
<p><code>[[1., 2., 3.], [0., 2., 1.]]</code></p>
<h3>Create Basic Array</h3>
<p>To create an array the np.array() can be used:</p>
<pre><code>import numpy as np
a = np.array([1, 2, 3])
</code></pre>
<p>To fill the new array with zero's or ones:</p>
<pre><code>np.zeros(2)
# result is array([0., 0.])

np.ones(2)
# result is array([1., 1.])
</code></pre>
<p>Or even an empty array, it's filled with random data:</p>
<pre><code>np.empty(3)
# result array([3., 2., 1.])
</code></pre>
<p>Or an evenly spaced array, giving it the first number, last number, and the step size:</p>
<pre><code>np.arrange(2, 9, 2)
# result array([2, 4, 6, 8])
</code></pre>
<p>To create an array with values with linearly spaced in specified intervals:</p>
<pre><code>np.linspace(0, 10, num=5)
# result array([0., 2.5, 5., 7.5, 10.])
</code></pre>
<p>To specify the data point, you can pass the data type into the dtype variable:</p>
<pre><code>x = np.ones(2, dtype=np.int64)
# result array([1, 1])
</code></pre>
<h2>Overview of Basic Terms</h2>
<p>ndarray.ndim
the number of axes or dimensions of the array</p>
<p>ndarray.shape
the dimensions of the array.</p>
<p>ndarray.size
the total elements of the array</p>
<p>ndarray.dtype
an object that describes the data type of the elements in the array</p>
<p>ndarray.itemsize
the size in byes of each element in the array</p>
<p>ndarray.data
the buffer containing the actual elements of the array</p>
<h2>Adding, Removing, Sorting Arrays</h2>
<p>Sorting an array is simple with np.sort() method. The sort method can specify the axis, kind and order of the array.</p>
<pre><code class="language-python">arr = np.array([4, 3, 2, 1, 0, 100, 101])
np.sort(arr)

# result array([0, 1, 2, 3, 4, 100, 101])
</code></pre>
<p>Other types of arrays sorts include:</p>
<ul>
<li>argsort: indirect sort of a specific axis</li>
<li>lexsort: indirect stable sort on multiple keys</li>
<li>searchsorted: finds elements in a sorted array</li>
<li>partition: partial sort</li>
</ul>
<p>To concatenate arrays use np.concatenate()</p>
<pre><code>a = np.array([1, 2, 3, 4])
b = np.array([5, 6, 7, 8])

# result array([1, 2, 3, 4, 5, 6, 7, 8])
</code></pre>
<h2>Find Size of Array</h2>
<p>To find the number of axis or dimensions of an array use ndarray.ndim. This returns a single integer.</p>
<p>To find the total number of elements in an array use ndarray.size. This returns a single integer.</p>
<p>To find the elements stored along each dimension of the array, ndarray.shape. For example of if there was a 2-D array with 2 rows and 3 columns then shape of the array would be (2, 3)</p>
<h2>Reshape An Array</h2>
<p>To reshape an array use the arr.reshape(). This method gives us a new shape to an array without changing the data. The one rule is that whatever the new shape of the array, both the new and old shaped arrays need to have the same number of elements.</p>
<pre><code>a = np.arange(6)
print(a)
[0, 1, 2, 3, 4, 5]

b = a.reshape(3, 2)
print(b)
[[0, 1], [2, 3], [4, 5]]
</code></pre>
<p>Other options that can be passed to the reshape method are newshape and order.</p>
<p>Newshape is the new shape that you want. That can be an integer or a tuble of integers.</p>
<p>order: C means to read/write the elements using a C-like index order.
F means to read/write the elements using a Fortran order.
A means to read/write using a Fortran like index order if a is Fortran contiguous in memeory, or C-like order otherwise.</p>
<p>These options are the internal organization of NumPy's arrays. Essentially, what is done in reordering concerns whether it's more important to preserve the indexing convention or to not reorder the data.</p>
<h2>How to Convert a 1D Array into a 2D Array</h2>
<p>Topics are np.newaxis, np.expand_dims</p>
<p>Using np.newaxis and np.expand_dims increases the dimensions of a current array.</p>
<pre><code>a = np.array([1, 2, 3, 4, 5, 6])
a.shape
(6,)
</code></pre>
<p>Then to add a new axis to the array.</p>
<pre><code>a2 = a[np.newaxis, :]
a2.shape
(1, 6)
</code></pre>
<p>For a new row vector:</p>
<pre><code>row_vector = a[np.newaxis, :]
row_vector.shape
(1, 6)
</code></pre>
<p>For a new column vector:</p>
<pre><code>col_vector = a[:, np.newaxis]
col_vector.shape
(6, 1)
</code></pre>
<p>Then to insert a new axis at a specific position, use np.expand_dims:</p>
<pre><code>a = np.array([1, 2, 3, 4, 5, 6])
a.shape
(6,)
b = np.expand_dims(a, axis=1)
b.shape
(6, 1)
</code></pre>
<p>And then to add an axis at index position 0:</p>
<pre><code>c = np.expand_dims(a, axis=0)
c.shape
(1, 6)
</code></pre>
<h2>Indexing and Slicing</h2>
<p>For slicing and using index in NumPy it's the same as in Python.</p>
<p>For an array like this:</p>
<pre><code>a = np.array([[1 , 2, 3, 4], [1, 2, 6, 7], [9, 10, 11, 12]])
</code></pre>
<p>To print the values of the array that are less than 5:</p>
<pre><code>print(a[a &lt; 5])
[1 2 3 4 1 2]
</code></pre>
<p>To print the values that are more than 5:</p>
<pre><code>print(a[a &gt;=5])
[ 6  7  9 10 11 12]
</code></pre>
<p>To print the numbers that are even:</p>
<pre><code>print(a[a%2==0])
[ 2  4  2  6 10 12]
</code></pre>
<p>To select for more than one condition using bitwise operators:</p>
<pre><code>print(a[(a &gt; 2) &amp; (a &lt; 11)])
[ 3  4  6  7  9 10]
</code></pre>
<p>To find the nonzero elements of an array:</p>
<pre><code>nonzero = np.nonzero(a &lt; 5)
print(nonzero)
(array([0, 0, 0, 0, 1, 1]), array([0, 1, 2, 3, 0, 1]))
</code></pre>
<p>This is a tuple of arrays that were returned. One tuple of each dimension.</p>
<p>The first array is the row indices where the values that are less than five are found.</p>
<p>The second array represents the column indices are where the values are found.</p>
<h2>Create an array from existing data</h2>
<p>This covers slicing, indexing, np.vstack(), np.hstack(), np.hsplit(), .view(), copy().</p>
<p>Create a new array from a section of an existing array.</p>
<p>Start with this array:</p>
<pre><code>a = np.array([1, 2, 3, 4, 5, 6, 7])
</code></pre>
<pre><code class="language-python">arr1 = a[2:5]
# result array([3, 4, 5])
</code></pre>
<p>Arrays can be stacked. If you have two arrays like:</p>
<pre><code class="language-python">a1 = np.array([[1, 1], [2, 2]])
a2 = np.array([[3, 3], [4, 4]])
</code></pre>
<p>Then use vstack to stack them vertically:</p>
<pre><code class="language-python">np.vstack(a1, a2)
# result array([[1, 1], [2, 2], [3, 3], [4, 4]])
</code></pre>
<p>Arrays can be stacked horizontally as well with hstack:</p>
<pre><code class="language-python">np.hstack((a1, a2))
# result array([[1, 1, 3, 3], [2, 2, 4, 4]])
</code></pre>
<p>Arrays can be split in several smaller parts by using hsplit.</p>
<p>The arrays can be split into the number of equally shaped arrays.</p>
<p>Or return the columns after the division should occur.</p>
<pre><code class="language-python">x = np.arange(1, 25)

# result array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])

np.split(x, 3)
# result [array([1, 2, 3, 4, 5, 6, 7, 8]), array([ 9, 10, 11, 12, 13, 14, 15, 16]), array([17, 18, 19, 20, 21, 22, 23, 24])]
</code></pre>
<p>A shallow copy can be made with the view method.</p>
<p>NumPy function's and operations will return views whenever possible. This saves memory and is faster. If the data in the view is modified then so is the original array.</p>
<p>In that way it's a bit like passing information/parameters by reference.</p>
<h2>Basic array operations</h2>
<p>This section talks about addition, subtraction, multiplication, and division of NumPy arrays.</p>
<h3>Adding arrays</h3>
<p>Two arrays can be added together with the addition signs. This adds the values in the arrays.</p>
<pre><code class="language-python">data = np.array([1, 2])
ones = np.ones(2, dtype=int)
data + ones

# result array([2, 3])
</code></pre>
<p>Here's an example of other types of math that can be done with arrays. Like subtraction, multiplication, and division.</p>
<pre><code class="language-python">data = np.array([1, 2])
ones = np.ones(2, dtype=int)

data - ones
# result array([0, 1])

data * data
# result array([1, 4])

data / data
# result array([1., 1.])
</code></pre>
<p>To sum up all the values in an array, use the sum array.</p>
<pre><code class="language-python">a = np.array([1, 2, 3, 4])
a.sum()

# result 10
</code></pre>
<p>Then 2D arrays can be summed over the axis.</p>
<pre><code class="language-python">b = np.array([[1, 1], [2, 2]])
b.sum(axis=0)
# result array([3, 3])
</code></pre>
<p>Or sum over the columns:</p>
<pre><code class="language-python">b.sum(axis=1)
# result array([2, 4])
</code></pre>
<h3>Broadcasting</h3>
<p>When you want to carry out an operation between an array and a single operation.
Also, known as carrying out an operation between a vector and a scalar.
You can also carry out an operation between arrays of different sizes.</p>
<pre><code class="language-python">data = np.array([1.0, 2.0])
data * 1.5

# result array([1.6, 3.2])
</code></pre>
<p>NumPy understands that it should multiply each value in the array by the scalar. This is called Broadcasting and it allows NumPy to perform repeated operations on each cell. And on arrays of different shapes.</p>
<h3>Aggregate Function</h3>
<p>In addition to min, max and sum, you can also do aggregation on arrays like <em>mean</em> to the average and <em>prod</em> to get the result of multiplying the elements together. <em>std</em> can be used to get the standard deviation.</p>
<h3>Generate Random Numbers</h3>
<p>Using NumPy's random generation on creating arrays is very useful.
For example, you can randomly generate the initial data for an artificial neural network. You can split the data into random sets.
And you can randomly shuffle your dataset.</p>
<p>The <em>Generator.integers</em> is used to generate random integers.</p>
<h3>Unique</h3>
<p>Getting the unique numbers out of an NumPy array is simple with np.unique. Just pass the array into np.unique() and out pops only the unique values from it.
Unique values can be gotten from 2 D arrays as well.</p>
<h3>Transposing and reshaping a matrix</h3>
<p>To reshape and transpose arrays you can use arr.reshape(), arr.transpose(), or arr.T
You might need to switch the dimensions of a matrix. You can use the reshape function to alter the array.</p>
<h3>Reverse An Array</h3>
<p>To reverse an array, you can use the np.flip() method.
Reversing a 2D array works much the same way as reversing a single dimensional array.
<code>reversed = np.flip(arr_2d) print(reversed) [[12 11 10  9] [ 8  7  6  5] [ 4  3  2  1]]</code></p>
<p>Reversing a 2D only with the rows</p>
<p><code>reversed = np.flip(arr_2s, axis=0) print(reversed) [[ 9 10 11 12] [ 5  6  7  8] [ 1  2  3  4]]</code></p>
<p>Or only the columns:</p>
<p><code>reversed = np.flip(arr_2d, axis=1) print(reversed) [[ 4  3  2  1] [ 8  7  6  5] [12 11 10  9]]</code></p>
<p>You can also reverse the contents of just one column or row.</p>
<p><code>arr_2d[1] = np.flip(arr_2d[1]) print(arr_2d) [[ 1  2  3  4] [ 8  7  6  5] [ 9 10 11 12]]</code></p>
<p>Or even the second column:</p>
<p><code>arr_2d[:,1] = np.flip(arr_2d[:,1]) print(arr_2d) [[ 1 10  3  4] [ 8  7  6  5] [ 9  2 11 12]]</code></p>
<h3>Flattening An Array</h3>
<p>The two best arrays are .flatten() and ravel()</p>
<p>The difference is that ravel() doesn't just create a copy, it's a reference to the parent array. If you change the child array, then the parent arrays changes.</p>
<p><code>a1 = x.flatten() a1[0] = 99 print(x)  # Original array [[ 1  2  3  4] [ 5  6  7  8] [ 9 10 11 12]] print(a1)  # New array [99  2  3  4  5  6  7  8  9 10 11 12]</code></p>
<p>And then ravel:</p>
<p><code>a2 = x.ravel() a2[0] = 98 print(x)  # Original array [[98  2  3  4] [ 5  6  7  8] [ 9 10 11 12]] print(a2)  # New array [98  2  3  4  5  6  7  8  9 10 11 12]</code></p>
<h3>Help and DocString</h3>
<p>For all of the NumPy's functions a built in help menu is included.</p>
<p>`
help(max)
Help on built-in function max in module builtins:</p>
<p>max(...)
max(iterable, *[, default=obj, key=func]) -&gt; value
max(arg1, arg2, *args, *[, key=func]) -&gt; value</p>
<p>With a single iterable argument, return its biggest item. The
default keyword-only argument specifies an object to return if
the provided iterable is empty.
With two or more arguments, return the largest argument.</p>
<p><code>A shortcut for the help is the question mark. Like:</code></p>
<p>max?
max(iterable, *[, default=obj, key=func]) -&gt; value
max(arg1, arg2, *args, *[, key=func]) -&gt; value</p>
<p>With a single iterable argument, return its biggest item. The
default keyword-only argument specifies an object to return if
the provided iterable is empty.
With two or more arguments, return the largest argument.
Type:      builtin_function_or_method</p>
<p><code>This can be used on the instances of the arrays, not just the object methods.</code></p>
<p>a = np.array([1, 2, 3, 4, 5, 6])</p>
<p><code>Then you can get a lot of information by the question mark on the a instance.</code></p>
<p>a?
Type:            ndarray
String form:     [1 2 3 4 5 6]
Length:          6
File:            ~/anaconda3/lib/python3.9/site-packages/numpy/<strong>init</strong>.py
Docstring:       <no docstring>
Class docstring:
ndarray(shape, dtype=float, buffer=None, offset=0,
strides=None, order=None)</p>
<p>An array object represents a multidimensional, homogeneous array
of fixed-size items.  An associated data-type object describes the
format of each element in the array (its byte-order, how many bytes it
occupies in memory, whether it is an integer, a floating point number,
or something else, etc.)</p>
<h3>Math Formulas</h3>
<p>One of the good things about working with NumPy that makes it so useful is being able to work with mathematical formulas. You can use formulas that work on arrays.
Statics is a great use case and the mean square formula is an often used formula in supervised machine leaning models that deal with regression.</p>
<p>Using this formula with number might go something like this:</p>
<p><code>error = (1/n) * np.sum(np.square(predictions - labels))</code></p>
<p>Predictions and labels can be any size, small to large. As long as they are the same size as each other.</p>
<h3>Saving and Loading NumPy objects</h3>
<p>Saving and loading NumPy arrays without having to re-run the code is a useful thing to do. The ndarray objects can be saved and loaded from the disk files with <code>loadtxt</code> and <code>savetxt</code> function.</p>
<p>The load and save function can handle NumPy binary files that have a .npy file extension. And then a savez function can do the same, handle file, but ones with an .npz file extension.</p>
<p>Those two files, the .npy and .npz file extension, they store the data, shape of the data, and the dtype that are required to reconstruct the ndarray. So a user can directly retrieve the data instead of having to run the NumPy code to get the data again.</p>
<p>Another reason this is useful is using the data from machine to machine even when there is different architectures on the machines.</p>
<p>A user can store a single ndarray object as an .npy file using an np.save.  More than one ndarray objects can be saved as file extension .npz by using the <code>np.savez</code>.</p>
<p>Then, if a user wants to store a lot of info/array objects, it might be useful to use a compressed npz format with savez_compressed.</p>
<p>Here's an example of saving an array with <code>np.save()</code>:</p>
<p><code>a = np.array([1,2,3,7,10]) np.save('filename', a)</code></p>
<p>Then that same file can be loaded:
<code>b = np.load('filename.npy')</code></p>
<p>The array then can be used like usual. NumPy arrays can also be saved into a plain text file, like a .csv or .txt with <code>np.savetxt</code>.</p>
<p><code>csv_array = np.array([9, 8, 6, 4]) np.savetxt('filename.csv', csv_array)</code></p>
<p>Loading is very similar to loading an .npy extension.
<code>csv_a = np.loadtxt('filename.csv')</code></p>
<p>The txt type of function for saving and retrieving are useful in part because they can accept optional parameters like header, footer, and delimiter. While text files can be easier for sharing, keep in mind that .npy and .npz files are smaller and faster to read.</p>
<p>And example of the <code>savetxt</code> function with headers and delimiters:</p>
<p><code>np.savetxt('np.csv', a, fmt='%.2f', delimiter=',', header='1,  2,  3,  4')</code></p>
<p>When there is missing data or more sophisticated handling of data is needed the <code>genfromtxt</code> function is useful.</p>

    </main>
    <footer>
        <div>
            <div>Sponsored by Frog Protection Services</div>
            <div>Do you have Frog Protection?</div>
        </div>
        <div>a <code class="logo">hello world</code> production</div>
    </footer>
</body>
</html>